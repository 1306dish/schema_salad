"@context":
  "@base": "https://w3id.org/cwl/salad#"
  "sld": "https://w3id.org/cwl/salad#"
  "avro": "https://w3id.org/cwl/avro#"
  "dct": "http://purl.org/dc/terms/"
  "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
  "rdfs": "http://www.w3.org/2000/01/rdf-schema#"

"@graph":
- name: "Semantic_Annotations_for_Linked_Avro_Data"
  type: documentation
  doc: |
    # Semantic Annotations for Linked Avro Data (SALAD)

    Author:

    * Peter Amstutz <peter.amstutz@curoverse.com>, Curoverse

    Contributers:

    * Nebojša Tijanić <nebojsa.tijanic@sbgenomics.com>, Seven Bridges Genomics
    * Stian Soiland-Reyes [soiland-reyes@cs.manchester.ac.uk](mailto:soiland-reyes@cs.manchester.ac.uk), University of Manchester
    * Hervé Ménager <herve.menager@gmail.com>, Institut Pasteur

    # Abstract

    Salad is a schema language for describing the structure and semantics of
    linked data in JSON or YAML documents.  Salad builds on JSON-LD and the
    Apache Avro data serialization system, and extends Avro with features for
    rich data modeling such as inheritance, template specialization, object
    identifiers, and object references.

    # Status of This Document

    This document is the product of the [Common Workflow Language working
    group](https://groups.google.com/forum/#!forum/common-workflow-language).  The
    latest version of this document is available in the "schema_salad" directory at

    https://github.com/common-workflow-language/schema_salad

    The products of the CWL working group (including this document) are made available
    under the terms of the Apache License, version 2.0.

    # Introduction

    Salad is a schema language for describing structured linked data documents
    in JSON or YAML documents.  A Salad schema provides rules for
    preprocessing, structural validation, and link checking for documents
    described by a Salad schema.

    Salad builds on JSON-LD and the Apache Avro data serialization system, and
    extends Avro with features for rich data modeling such as inheritance,
    template specialization, object identifiers, and object references.

    Salad was developed to provide a bridge between the record oriented data
    modeling supported by Apache Avro and the Semantic Web.

    ## Introduction to 1.0

    This is the first version of Schema Salad.  It is developed concurrently
    with draft 3 of the Common Workflow Language for use in specifying the
    Common Workflow Language.

    ## References to Other Specifications

    * [JSON](http://json.org)
    * [JSON-LD](http://json-ld.org)
    * [YAML](http://yaml.org)
    * [Avro](https://avro.apache.org/docs/current/spec.html)
    * [Uniform Resource Identifier (URI): Generic Syntax](https://tools.ietf.org/html/rfc3986)
    * [Resource Description Framework (RDF)](http://www.w3.org/RDF/)

    ## Scope

    This document describes the syntax, data model, algorithms, and schema
    language for working with Salad documents.  It is not intended to document
    a specific implementation of Salad, however it may serve as a reference for
    the behavior of conforming implementations.

    ## Terminology

    The terminology used to describe Salad documents is defined in the Concepts
    section of the specification. The terms defined in the following list are
    used in building those definitions and in describing the actions of an
    Salad implementation:

    **may**: Conforming Salad documents and Salad implementations are permitted but
    not required to be interpreted as described.

    **must**: Conforming Salad documents and Salad implementations are required
    to be interpreted as described; otherwise they are in error.

    **error**: A violation of the rules of this specification; results are
    undefined. Conforming implementations may detect and report an error and may
    recover from it.

    **fatal error**: A violation of the rules of this specification; results
    are undefined. Conforming implementations must not continue to process the
    document and may report an error.

    **at user option**: Conforming software may or must (depending on the modal verb in
    the sentence) behave as described; if it does, it must provide users a means to
    enable or disable the behavior described.

    # Document model

    ## Data concepts

    An **object** is a data structure equivalent to the "object" type in JSON,
    consisting of a unordered set of name/value pairs (referred to here as
    **fields**) and where the name is a string and the value is a string, number,
    boolean, array, or object.

    A **document** is a file containing a serialized object, or an array of
    objects.

    A **document type** is a class of files that share a common structure and
    semantics.

    A **document schema** is a formal description of the grammar of a document type.

    A **base URI** is a context-dependent URI used to resolve relative references.

    An **identifier** is a URI that designates a single document or single
    object within a document.

    A **vocabulary** is the set of symbolic field names and enumerated symbols defined
    by a document schema, where each term maps to absolute URI.

    ## Syntax

    Conforming Salad documents are serialized and loaded using YAML syntax and
    UTF-8 text encoding.  Salad documents are written using the JSON-compatible
    subset of YAML.  Features of YAML such as headers and type tags that are
    not found in the standard JSON data model must not be used in conforming
    Salad documents.  It is a fatal error if the document is not valid YAML.

    A Salad document must consist only of either a single root object or an
    array of objects.

    ## Document context

    ### Implied context

    The implicit context consists of the vocabulary defined by the schema and
    the base URI.  By default, the base URI must be the URI that was used to
    load the document.  It may be overidden by an explicit context.

    ### Explicit context

    If a document consists of a single root object, this object may contain the
    field `@context` consisting of a string, object, array of strings, or array
    of objects.  If so, it must be interpreted as a limited form of JSON-LD
    context.  The following JSON-LD directives must be honored:

      * `@base`: set the base URI for the document.

    Additional directives beginning with `@` must be ignored.  The remaining
    vocabulary defined in the context must be interpreted as namespace prefixes
    used during identifier expansion.

    ## Document graph

    If a document consists of a single root object, this object may contain the
    field `@graph` consisting of an array of objects.  If so, the outermost
    document root object the document processed with the contents of `@graph`
    considered the main document.  This permits declaring `@context` at the
    root to cover the whole the document, while logically declaring multiple
    objects at the top level.

    ## Document metadata

    If a document consists of a single root object, metadata about the
    document, such as authorship, may be declared in the root object.

    ## Document schema

    Document preprocessing, link validation and schema validation require a
    document schema.  A schema may consist of:

      * At least one record definition object which defines valid fields that
      make up a record type.  Record field definitions include the valid types
      that may be assigned to each field and annotations to indicate fields
      that represent identifiers and links, described below in "Semantic
      Annotations".

      * Any number of enumerated type objects which define a set of finite set of symbols that are
      valid value of the type.

      * Any number of documentation objects which allow in-line documentation of the schema.

    The schema for defining a salad schema (the metaschema) is described in
    detail in "Schema validation".

    ### Record field annotations

    In a document schema, record field definitions may include the field
    `jsonldPredicate`, which may be either a string or object.  Implementations
    must use the following document preprocessing of fields by the following
    rules:

      * If the value of `jsonldPredicate` is `@id`, the field is an identifier
      field.

      * If the value of `jsonldPredicate` is an object, and contains that
      object contains the field `_type` with the value `@id`, the field is a
      link field.

    ## Document traversal

    To perform document document preprocessing, link validation and schema
    validation, the document must be recursively traversed depth-first starting
    from the fields or array items of the root object or array and visiting
    each child item which contains an object or arrays.

    ## Document preprocessing

    After processing the explicit context (if any), document preprocessing
    begins.  Starting from the document root, object fields values or array
    items which containin objects or arrays are recursively traversed
    depth-first.  For each visited object, `import` and `include` directives,
    identifier fields, and link fields must be processed as described below.
    The order of traversal of child nodes within a parent node is undefined.

    ### Identifier resolution

    The schema may designate one or more fields as identifier fields to
    identify specific objects.  Processing must resolve relative identifiers to
    absolute identifiers using the following rules:

      * If an identifier URI is prefixed with `#` it is a URI relative
      fragment identifier.  It is resolved relative to the base URI by setting
      or replacing the fragment portion of the base URI.

      * If an identifier URI does not contain a scheme and is not prefixed
      `#` it is a parent relative fragment identifier.  It is resolved relative
      to the base URI by the following rule: if the base URI does not contain a
      document fragment, set the fragment portion of the base URI.  If the base
      URI does contain a document fragment, append a slash `/` followed by the
      identifier field to the fragment portion of the base URI.

      * If an identifier URI begins with a namespace prefix declared in
      `@context` followed by a colon `:`, the prefix and colon must be replaced
      by the namespace declared in `@context`.

      * If an identifier URI is an absolute URI consisting of a scheme and
      path, no processing occurs.

    When preprocessing visits a node containing an identifier, that identifier
    must be used as the base URI to process child nodes.

    It is an error for more than one object in a document to have the same
    absolute URI.

    #### Example

    The `id` field is the identifier field in the following example.

    ```
    {
      "@context": {
        "acid": "http://example.com/acid#"
      },
      "id": "http://example.com/base",
      "form": {
        "id": "one",
        "things": [
          {
            "id": "two"
          },
          {
            "id": "#three",
          },
          {
            "id": "four#five",
          },
          {
            "id": "acid:six",
          }
        ]
      }
    }

    ```

    Becomes:

    ```
    {
      "id": "http://example.com/base",
      "form": {
        "id": "http://example.com/base#one",
        "things": [
          {
            "id": "http://example.com/base#one/two"
          },
          {
            "id": "http://example.com/base#three"
          },
          {
            "id": "http://example.com/base#one/four#five",
          },
          {
            "id": "http://example.com/acid#six",
          }
        ]
      }
    }
    ```

    ### Link resolution

    The schema may designate one or more fields as link fields which reference
    to objects.  Processing must resolve references to either absolute
    references or vocabulary terms using the following rules:

      * If a reference URI is prefixed with `#` it is a relative
      fragment identifier.  It is resolved relative to the base URI by setting
      or replacing the fragment portion of the base URI.

      * If a reference URI does not contain a scheme and is not prefixed with
      `#` it is a path relative reference.  If the reference URI contains `#`
      in any position other than the first character, the reference URI must be
      divided into a path portion and a fragment portion split on the first
      instance of `#`.  The path portion is resolved relative to the base URI
      by the following rule: if the path portion of the base URI ends in a
      slash `/`, append the path portion of the reference URI to the path
      portion of the base URI.  If the path portion of the base URI does not
      end in a slash, replace the final path segment with the path portion of
      the reference URI.  Replace the fragment portion of the base URI with the
      fragment portion of the reference URI.

      * If a reference URI begins with a namespace prefix declared in
      `@context` followed by a colon `:`, the prefix and colon must be replaced
      by the namespace declared in `@context`.

      * If there is a vocabulary term which maps to the URI of an absolute
      reference resolved by the above rules, the reference must be replace with
      the vocabulary term.

      * If a reference URI is an absolute URI consisting of a scheme and path
      and is not part of the vocabulary, no processing occurs.

    Link resolution must not affect the base URI used to resolve identifiers
    and other links.

    #### Example

    The `link` field is the reference field in the following example.  The
    base URI is `http://example.com/base`

    ```
    {
      "@context": {
        "acid": "http://example.com/acid#"
        "red": "http://example.com/acid#red"
      },
      "link": "http://example.com/base/zero",
      "form": {
        "link": "one",
        "things": [
          {
            "link": "two"
          },
          {
            "link": "#three",
          },
          {
            "link": "four#five",
          },
          {
            "link": "acid:six",
          },
          {
            "link": "red",
          },
          {
            "link": "http://example.com/acid#red",
          }
        ]
      }
    }

    ```

    Becomes:

    ```
    {
      "link": "http://example.com/base/zero",
      "form": {
        "link": "http://example.com/one",
        "things": [
          {
            "link": "http://example.com/two"
          },
          {
            "link": "http://example.com/base#three"
          },
          {
            "link": "http://example.com/four#five",
          },
          {
            "link": "http://example.com/acid#six",
          },
          {
            "link": "red",
          },
          {
            "link": "red",
          }
        ]
      }
    }
    ```

    ### Field name resolution

    The document schema declares the vocabulary of known field names.  During
    preprocessing traversal, field name in the document which are not part of
    the schema vocabulary must be resolved to absolute URIs.  Under "strict"
    validation, it is an error for a document to include fields which are not
    part of the vocabulary and not resolvable to absolute URIs.  Fields names
    which are not part of the vocabulary are resolved using the following
    rules:

      * If an field name URI begins with a namespace prefix declared in the
      document context (`@context`) followed by a colon `:`, the prefix and
      colon must be replaced by the namespace declared in `@context`.

      * If there is a vocabulary term which maps to the URI of a resolved
      field, the field name must be replace with the vocabulary term.

      * If a field name URI is an absolute URI consisting of a scheme and path
      and is not part of the vocabulary, no processing occurs.

    Field name resolution is not relative.  It must not be affected by the base
    URI.

    #### Example

    The `form` field is part of the vocabulary in the following example.  The
    base URI is `http://example.com/base`

    ```
    {
      "@context": {
        "acid": "http://example.com/acid#"
      },
      "form": {
        "http://example.com/extension": "one",
      },
      "acid:extension": "two"
    }

    ```

    Becomes:

    ```
    {
      "form": {
        "http://example.com/extension": "one",
      },
      "http://example.com/acid#extension": "two"
    }
    ```

    ### Import

    During preprocessing traversal, an implementation must resolve `import`
    directives.  An `import` directive is an object consisting of exactly one
    field `import` specifying a URI string.  It is an error if there are
    additional fields in the `include` object, such additional fields must be
    ignored.

    The URI string must be resolved to an absolute URI using the link
    resolution rules described previously.  Implementations must support
    loading from `file`, `http` and `https` resources.  The URI referenced by
    `import` must be loaded and recursively preprocessed as a Salad document.
    The external imported document does not inherit the context of the
    importing document, and the default base URI for processing the imported
    document must be the URI used to retrieve the imported document.  If the
    `import` URI includes a document fragment, the fragment must be excluded
    from the base URI used to preprocess the imported document.

    Once loaded and processed, the `import` node is replaced in the document
    structure by the object or array yielded from the import operation.

    URIs may reference document fragments which refer to specific an object in
    the target document.  This indicates that the `import` node must be
    replaced by only the object with the appropriate fragment identifier.

    It is a fatal error if an import directive refers to an external resource
    or resource fragment which does not exist or is not accessible.

    #### Example

    parent.yml:
    ```
    {
      "form": {
        "bar": {
          "import": "import.yml"
          }
      }
    }

    ```

    import.yml:
    ```
    {
      "hello": "world"
    }

    ```

    Becomes:

    ```
    {
      "form": {
        "bar": {
          "hello": "world"
        }
      }
    }
    ```

    ### Include

    During preprocessing traversal, an implementation must resolve `include`
    directives.  An `include` directive is an object consisting of exactly one
    field `include` specifying a URI string.  It is an error if there are
    additional fields in the `include` object, such additional fields must be
    ignored.

    The URI string must be resolved to an absolute URI using the link
    resolution rules described previously.  The URI referenced by `import` must
    be loaded as a text data.  Implementations must support loading from
    `file`, `http` and `https` resources.  Implementations may transcode the
    character encoding of the text data to match that of the parent document,
    but must not interpret or parse the text document in any other way.

    Once loaded, the `include` node is replaced in the document structure by a
    string containing the text data loaded from the resource.

    It is a fatal error if an import directive refers to an external resource
    which does not exist or is not accessible.

    #### Example

    parent.yml:
    ```
    {
      "form": {
        "bar": {
          "include": "include.txt"
          }
      }
    }

    ```

    include.txt:
    ```
    hello world

    ```

    Becomes:

    ```
    {
      "form": {
        "bar": "hello world"
      }
    }
    ```

- name: "Link_Validation"
  type: documentation
  doc: |
    # Link validation

    Once a document has been preprocessed, an implementation may validate
    links.  The link validation traversal may visit fields which the schema
    designates as link fields and check that each URI references an existing
    object in the current document, an imported document, file system, or
    network resource.  Failure to validate links may be a fatal error.


- name: "Schema_validation"
  type: documentation
  doc: ""


- name: "JSON_LD_Context"
  type: documentation
  doc: |
    # Generating JSON-LD Context

    How to generate the json-ld context...


- name: PrimitiveType
  docParent: "#Schema_validation"
  type: enum
  symbols:
    - "avro:null"
    - "avro:boolean"
    - "avro:int"
    - "avro:long"
    - "avro:float"
    - "avro:double"
    - "avro:bytes"
    - "avro:string"
  doc: |
   Salad data types are based on Avro schema declarations.  Refer to the
   [Avro schema declaration documentation](https://avro.apache.org/docs/current/spec.html#schemas) for
   detailed information.

   ## Simple types

   * **null**: no value
   * **boolean**: a binary value
   * **int**: 32-bit signed integer
   * **long**: 64-bit signed integer
   * **float**: single precision (32-bit) IEEE 754 floating-point number
   * **double**: double precision (64-bit) IEEE 754 floating-point number
   * **bytes**: sequence of uninterpreted 8-bit unsigned bytes
   * **string**: Unicode character sequence


- name: "Any"
  type: enum
  symbols: ["#Any"]
  doc: |
    The **Any** type validates for any non-null value.


- name: JsonldPredicate
  type: record
  fields:
    - name: _id
      type: ["null", string]
      jsonldPredicate:
        _id: sld:_id
        _type: "@id"
        identity: true
    - name: _type
      type: ["null", string]
    - name: _container
      type: ["null", string]
    - name: identity
      type: ["null", boolean]
    - name: noLinkCheck
      type: ["null", boolean]


- name: SpecializeDef
  type: record
  fields:
    - name: specializeFrom
      type: string
      jsonldPredicate:
        _id: "sld:specializeFrom"
        _type: "@id"

    - name: specializeTo
      type: string
      jsonldPredicate:
        _id: "sld:specializeTo"
        _type: "@id"


- name: ComplexType
  type: record
  docParent: "#Schema_validation"
  doc: |
   * **record**: An object with one or more fields defined by name and type
   * **enum**: A value from a finite set of symbolic values
   * **array**: An ordered sequence of values

  abstract: true
  fields:
    - name: name
      type: string
      jsonldPredicate: "@id"

    - name: doc
      type: ["null", string]

    - name: docParent
      type: ["null", string]
      jsonldPredicate:
        _id: "sld:docParent"
        _type: "@id"

    - name: docAfter
      type: ["null", string]
      jsonldPredicate:
        _id: "sld:docAfter"
        _type: "@id"

    - name: jsonldPrefix
      type: ["null", string]

    - name: jsonldPredicate
      type:
        - "null"
        - string
        - "#JsonldPredicate"

    - name: documentRoot
      type: ["null", boolean]


- name: RecordField
  type: record
  docParent: "#Schema_validation"
  fields:
    - name: name
      type: string
      jsonldPredicate: "@id"

    - name: doc
      type: ["null", string]

    - name: type
      type:
        - "#PrimitiveType"
        - "#ComplexType"
        - "#Any"
        - string
        - type: array
          items:
            - "#PrimitiveType"
            - "#ComplexType"
            - "#Any"
            - string
      jsonldPredicate:
        _id: "avro:type"
        _type: "@vocab"

    - name: jsonldPrefix
      type: ["null", string]

    - name: jsonldPredicate
      type:
        - "null"
        - string
        - "#JsonldPredicate"


- name: RecordSchema
  type: record
  extends: "#ComplexType"
  documentRoot: true
  fields:
    - name: type
      doc: "Must be `record`"
      type:
        name: Record_symbol
        type: enum
        symbols:
          - "avro:record"
      jsonldPredicate:
        _id: "avro:type"
        _type: "@vocab"

    - name: abstract
      type: ["null", boolean]

    - name: "fields"
      type:
        - "null"
        - type: "array"
          items: "#RecordField"

      jsonldPredicate: "avro:fields"
      doc: "Defines the fields of the record."

    - name: extends
      type: ["null", string]
      jsonldPredicate:
        _id: "sld:extends"
        _type: "@id"

    - name: specialize
      type:
        - "null"
        - "#SpecializeDef"
        - type: array
          items: "#SpecializeDef"


- name: EnumSchema
  type: record
  extends: "#ComplexType"
  documentRoot: true
  fields:
    - name: type
      doc: "Must be `enum`"
      type:
        name: Enum_symbol
        type: enum
        symbols:
          - "avro:enum"
      jsonldPredicate:
        _id: "avro:type"
        _type: "@vocab"

    - name: "symbols"
      type:
        - type: "array"
          items: "string"
      jsonldPredicate:
        _id: "avro:symbols"
        _type: "@id"
        identity: true
      doc: "When `type` is `enum`, defines the set of valid symbols."


- name: ArraySchema
  type: record
  docParent: "#Schema_validation"
  fields:
    - name: type
      doc: "Must be `array`"
      type:
        name: Array_symbol
        type: enum
        symbols:
          - "avro:array"
      jsonldPredicate:
        _id: "avro:type"
        _type: "@vocab"


    - name: items
      type:
        - "#PrimitiveType"
        - "#ComplexType"
        - string
        - type: array
          items: [ "#PrimitiveType", "#ComplexType", string ]
      jsonldPredicate:
        _id: "avro:items"
        _type: "@vocab"
      doc: "When `type` is `array`, defines the type of the array elements."


- name: Documentation
  type: record
  docParent: "#Schema_validation"
  documentRoot: true
  fields:
    - name: name
      type: string
      jsonldPredicate: "@id"

    - name: type
      doc: "Must be `documentation`"
      type:
        name: Documentation_symbol
        type: enum
        symbols:
          - "sld:documentation"
      jsonldPredicate:
        _id: "avro:type"
        _type: "@vocab"


    - name: doc
      type: string

    - name: docParent
      type: ["null", string]
      jsonldPredicate:
        _id: "sld:docParent"
        _type: "@id"
